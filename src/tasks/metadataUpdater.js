const { getDB } = require('../services/database');
const { logger } = require('../services');
const { fetchSolscanData } = require('../services/solscan');

let isRunning = false;

async function updateMetadata(deps) {
    if (isRunning) return;
    isRunning = true;
    const { db } = deps;
    const now = Date.now();
    const oneHourAgo = now - (60 * 60 * 1000);
    const fiveMinsAgo = now - (5 * 60 * 1000);
    const twentyFourHoursAgo = now - (24 * 60 * 60 * 1000);

    try {
        // Fetch all tokens to update
        const tokens = await db.all(`SELECT mint, supply, decimals FROM tokens`);
        
        for (const t of tokens) {
            try {
                // 1. Get Best Pool (for Price)
                const pool = await db.get(`SELECT address, price_usd FROM pools WHERE mint = $1 ORDER BY liquidity_usd DESC LIMIT 1`, [t.mint]);
                
                let currentPrice = pool?.price_usd || 0;
                let volume24h = 0;
                let change24h = 0;
                let change1h = 0;
                let change5m = 0;

                // 2. Aggregate Volume from Candles (The Source of Truth)
                // We use the candles generated by the snapshotter which now filters fake volume
                const volRes = await db.get(`
                    SELECT SUM(c.volume) as vol_usd 
                    FROM candles_1m c 
                    JOIN pools p ON c.pool_address = p.address 
                    WHERE p.mint = $1 AND c.timestamp >= $2
                `, [t.mint, twentyFourHoursAgo]);
                
                volume24h = volRes?.vol_usd || 0;

                // 3. Calculate % Changes (Internal Data)
                if (pool) {
                    const getPriceAt = async (ts) => {
                        const res = await db.get(`SELECT close FROM candles_1m WHERE pool_address = $1 AND timestamp <= $2 ORDER BY timestamp DESC LIMIT 1`, [pool.address, ts]);
                        return res ? res.close : null;
                    };

                    const price24h = await getPriceAt(twentyFourHoursAgo);
                    const price1h = await getPriceAt(oneHourAgo);
                    const price5m = await getPriceAt(fiveMinsAgo);

                    if (currentPrice > 0) {
                        if (price24h) change24h = ((currentPrice - price24h) / price24h) * 100;
                        if (price1h) change1h = ((currentPrice - price1h) / price1h) * 100;
                        if (price5m) change5m = ((currentPrice - price5m) / price5m) * 100;
                    }
                }

                // 4. Fallback to Solscan ONLY if we have no internal data
                // This prevents "flickering" between our data and Solscan
                if (currentPrice === 0 || volume24h === 0) {
                    const solscan = await fetchSolscanData(t.mint);
                    if (solscan) {
                        if (currentPrice === 0 && solscan.priceUsd > 0) currentPrice = solscan.priceUsd;
                        if (volume24h === 0 && solscan.volume24h > 0) volume24h = solscan.volume24h;
                        if (change24h === 0) change24h = solscan.change24h;
                    }
                }

                // 5. Calculate Market Cap
                let marketCap = 0;
                if (currentPrice > 0) {
                    const decimals = t.decimals || 9;
                    const divisor = Math.pow(10, decimals);
                    const supply = parseFloat(t.supply || '0') / divisor;
                    marketCap = supply * currentPrice;
                }

                // 6. Save
                await db.run(`
                    UPDATE tokens 
                    SET volume24h = $1, marketCap = $2, priceUsd = $3, 
                        change1h = $4, change24h = $5, change5m = $6, 
                        timestamp = $7 
                    WHERE mint = $8
                `, [volume24h, marketCap, currentPrice, change1h, change24h, change5m, now, t.mint]);

                // Throttle updates slightly
                await new Promise(r => setTimeout(r, 100));

            } catch (err) {
                // logger.error(`Token update failed ${t.mint}: ${err.message}`);
            }
        }
    } catch (e) {
        logger.error(`Metadata Update Cycle Error: ${e.message}`);
    } finally {
        isRunning = false;
    }
}

function start(deps) {
    setInterval(() => updateMetadata(deps), 60000); // 1 min interval
    setTimeout(() => updateMetadata(deps), 5000);
}

// Export a direct update function for API calls
async function updateTokenStats(mint) {
    // Optional: Implement single token update logic here if needed
    // For now we rely on the cycle
}

module.exports = { start, updateTokenStats };
